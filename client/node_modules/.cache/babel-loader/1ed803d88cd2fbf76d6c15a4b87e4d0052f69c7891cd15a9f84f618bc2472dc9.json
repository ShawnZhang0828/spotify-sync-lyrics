{"ast":null,"code":"var _jsxFileName = \"C:\\\\Study\\\\VS Code\\\\spotify-lyrics-sync\\\\client\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\nimport Header from './components/Header';\nimport Lyrics from './components/Lyrics';\nimport axios from 'axios';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CLIENT_ID = \"07f45b95ceac490ba0871336604107e0\";\nconst CLIENT_SECRET = \"2896dd203a234606ab0e2ba2a2aa5ad8\";\nfunction App() {\n  _s();\n  const getCurrentTrack = async () => {\n    if (window.localStorage.getItem(\"token\") === null) {\n      return;\n    }\n    try {\n      const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n        headers: {\n          Authorization: `Bearer ${window.localStorage.getItem(\"token\")}`\n        }\n      });\n      if (response !== undefined) {\n        let trackName = response.data.item.name,\n          artistName = response.data.item.artists[0].name,\n          // TODO: could be more than one artists\n          trackID = response.data.item.id,\n          trackImg = response.data.item.album.images[0].url;\n        return {\n          trackName,\n          artistName,\n          trackID,\n          trackImg\n        };\n      } else {\n        return null;\n      }\n    } catch (error) {\n      console.log(error);\n      if (error.response.status === 401) {\n        window.localStorage.removeItem(\"token\");\n      }\n    }\n  };\n  const handleTrackChange = async () => {\n    // do something when the track changes\n    setCurrentLineIndex(0);\n    await getLyrics();\n  };\n  const getLyrics = async () => {\n    try {\n      const response = await axios.get(`https://spotify-lyric-api.herokuapp.com/?trackid=${track.trackID}`, {});\n      if (response !== undefined) {\n        var lines = response.data.lines.map(lineObj => {\n          delete lineObj.endTimeMs;\n          delete lineObj.syllables;\n          return lineObj;\n        });\n        setLyrics(lines);\n      } else {\n        setLyrics([{\n          startTimeMs: 0,\n          words: \" \"\n        }]);\n        console.log(\"lyrics not found\");\n      }\n    } catch (error) {\n      setLyrics([{\n        startTimeMs: 0,\n        words: \" \"\n      }]);\n      console.log(\"lyrics not found\");\n    }\n  };\n  const getProgress = async () => {\n    const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n      headers: {\n        Authorization: `Bearer ${window.localStorage.getItem(\"token\")}`\n      }\n    });\n    if (response) {\n      let trackStatus = response.data.progress_ms;\n      return trackStatus;\n    } else {\n      return null;\n    }\n  };\n  const refreshToken = async () => {\n    try {\n      const response = await axios.post({\n        url: 'https://accounts.spotify.com/api/token',\n        headers: {\n          'Authorization': 'Basic ' + (CLIENT_ID + ':' + CLIENT_SECRET).toString('base64')\n        },\n        form: {\n          grant_type: 'refresh_token',\n          refresh_token: window.localStorage.getItem(\"refresh-token\")\n        },\n        json: true\n      });\n      const newAccessToken = response.data.access_token;\n      window.localStorage.setItem('token', newAccessToken);\n    } catch (error) {\n      // console.log('Error refreshing token:', window.localStorage.getItem(\"refresh-token\"));\n    }\n  };\n\n  // Refresh token every 10 minutes\n  setInterval(() => {\n    refreshToken();\n  }, 8 * 1000); // 10 minutes in milliseconds\n\n  const [track, setTrack] = useState({});\n  const [lyrics, setLyrics] = useState({});\n  const [currentLineIndex, setCurrentLineIndex] = useState(0);\n  useEffect(() => {\n    const interval = setInterval(async () => {\n      const newTrack = await getCurrentTrack();\n      if (newTrack && JSON.stringify(newTrack) !== JSON.stringify(track)) {\n        setTrack(newTrack);\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [getCurrentTrack]);\n  useEffect(() => {\n    if (Object.keys(track).length !== 0) {\n      setCurrentLineIndex(0);\n      handleTrackChange();\n    }\n  }, [track]);\n  useEffect(() => {\n    if (lyrics.length > 0) {\n      const timer = setInterval(async () => {\n        const currentTime = await getProgress(); // Get the current time of the track\n        const index = lyrics.findIndex(line => line.startTimeMs >= currentTime); // Find the index of the line with a start time greater than or equal to the current time\n        if (index !== -1 && index !== currentLineIndex) {\n          setCurrentLineIndex(index > 0 ? index - 1 : 0);\n        }\n      }, 300); // Check every 100 milliseconds\n      return () => clearTimeout(timer);\n    }\n  }, [lyrics, currentLineIndex]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: lyrics.length > 0 ? /*#__PURE__*/_jsxDEV(Lyrics, {\n      lines: lyrics,\n      currentLineIndex: currentLineIndex,\n      bg_img: track.trackImg\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 28\n    }, this) : /*#__PURE__*/_jsxDEV(Header, {\n      initToken: window.localStorage.getItem(\"token\")\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 115\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 139,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"DRBCBaxqHhRerBAnZZh7smhpVGI=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["useEffect","useState","Header","Lyrics","axios","jsxDEV","_jsxDEV","CLIENT_ID","CLIENT_SECRET","App","_s","getCurrentTrack","window","localStorage","getItem","response","get","headers","Authorization","undefined","trackName","data","item","name","artistName","artists","trackID","id","trackImg","album","images","url","error","console","log","status","removeItem","handleTrackChange","setCurrentLineIndex","getLyrics","track","lines","map","lineObj","endTimeMs","syllables","setLyrics","startTimeMs","words","getProgress","trackStatus","progress_ms","refreshToken","post","toString","form","grant_type","refresh_token","json","newAccessToken","access_token","setItem","setInterval","setTrack","lyrics","currentLineIndex","interval","newTrack","JSON","stringify","clearInterval","Object","keys","length","timer","currentTime","index","findIndex","line","clearTimeout","className","children","bg_img","fileName","_jsxFileName","lineNumber","columnNumber","initToken","_c","$RefreshReg$"],"sources":["C:/Study/VS Code/spotify-lyrics-sync/client/src/App.js"],"sourcesContent":["import {useEffect, useState} from 'react';\nimport Header from './components/Header';\nimport Lyrics from './components/Lyrics';\nimport axios from 'axios';\n\nconst CLIENT_ID = \"07f45b95ceac490ba0871336604107e0\"\nconst CLIENT_SECRET = \"2896dd203a234606ab0e2ba2a2aa5ad8\"\n\nfunction App() {\n\n  const getCurrentTrack = async () => {\n    if (window.localStorage.getItem(\"token\") === null) {\n      return;\n    }\n    try {\n      const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n        headers: {\n          Authorization: `Bearer ${window.localStorage.getItem(\"token\")}`\n        },\n      })\n      if (response !== undefined) {\n        let trackName = response.data.item.name,\n            artistName = response.data.item.artists[0].name,   // TODO: could be more than one artists\n            trackID = response.data.item.id,\n            trackImg = response.data.item.album.images[0].url\n        return { trackName, artistName, trackID, trackImg }\n      } else {\n        return null;\n      }\n    } catch (error) {\n      console.log(error);\n      if (error.response.status === 401) {\n        window.localStorage.removeItem(\"token\")\n      }\n    }\n    \n  }\n\n  const handleTrackChange = async () => {\n    // do something when the track changes\n    setCurrentLineIndex(0);\n    await getLyrics();\n  };\n\n  const getLyrics = async () => {\n    try {\n      const response = await axios.get(`https://spotify-lyric-api.herokuapp.com/?trackid=${track.trackID}`, {})\n      if (response !== undefined) {\n        var lines = response.data.lines.map(lineObj => {\n          delete lineObj.endTimeMs;\n          delete lineObj.syllables;\n          return lineObj;\n        })\n        setLyrics(lines);\n      } else {\n        setLyrics([{startTimeMs: 0, words: \" \"}]);\n        console.log(\"lyrics not found\");\n      }\n    } catch (error) {\n        setLyrics([{startTimeMs: 0, words: \" \"}]);\n        console.log(\"lyrics not found\");\n    }\n    \n    \n  }\n\n  const getProgress = async () => {\n    const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n      headers: {\n        Authorization: `Bearer ${window.localStorage.getItem(\"token\")}`\n      },\n    })\n    if (response) {\n      let trackStatus = response.data.progress_ms\n      return trackStatus\n    } else {\n      return null;\n    }\n  }\n\n  const refreshToken = async () => {\n    try {\n      const response = await axios.post({\n        url: 'https://accounts.spotify.com/api/token',\n        headers: { 'Authorization': 'Basic ' + (CLIENT_ID + ':' + CLIENT_SECRET).toString('base64') },\n        form: {\n          grant_type: 'refresh_token',\n          refresh_token: window.localStorage.getItem(\"refresh-token\")\n        },\n        json: true\n      });\n      const newAccessToken = response.data.access_token;\n      window.localStorage.setItem('token', newAccessToken);\n    } catch (error) {\n      // console.log('Error refreshing token:', window.localStorage.getItem(\"refresh-token\"));\n    }\n  };\n  \n  // Refresh token every 10 minutes\n  setInterval(() => {\n    refreshToken();\n  }, 8 * 1000); // 10 minutes in milliseconds\n\n  const [track, setTrack] = useState({});\n  const [lyrics, setLyrics] = useState({});\n  const [currentLineIndex, setCurrentLineIndex] = useState(0);\n\n  useEffect(() => {\n    const interval = setInterval(async () => {\n      const newTrack = await getCurrentTrack();\n      if (newTrack && JSON.stringify(newTrack) !== JSON.stringify(track)) {\n        setTrack(newTrack);\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [getCurrentTrack]);\n\n  useEffect(() => {\n    if (Object.keys(track).length !== 0) {\n      setCurrentLineIndex(0);\n      handleTrackChange();\n    }\n  }, [track]);\n\n  useEffect(() => {\n    if (lyrics.length > 0) {\n      const timer = setInterval(async () => {\n        const currentTime = await getProgress(); // Get the current time of the track\n        const index = lyrics.findIndex((line) => line.startTimeMs >= currentTime); // Find the index of the line with a start time greater than or equal to the current time\n        if (index !== -1 && index !== currentLineIndex) {\n          setCurrentLineIndex(index > 0 ? index - 1 : 0);\n        }\n      }, 300); // Check every 100 milliseconds\n      return () => clearTimeout(timer);\n    }\n  }, [lyrics, currentLineIndex]);\n\n  return (\n    <div className=\"container\">\n      {lyrics.length > 0 ? <Lyrics lines={lyrics} currentLineIndex={currentLineIndex} bg_img={track.trackImg}/> : <Header initToken={window.localStorage.getItem(\"token\")}/>}\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
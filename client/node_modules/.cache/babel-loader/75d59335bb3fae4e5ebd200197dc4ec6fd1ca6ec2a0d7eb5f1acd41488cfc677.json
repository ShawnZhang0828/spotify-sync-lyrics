{"ast":null,"code":"var _jsxFileName = \"C:\\\\Study\\\\VS Code\\\\spotify-lyrics-sync\\\\client\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\nimport Header from './components/Header';\nimport Lyrics from './components/Lyrics';\nimport axios from 'axios';\n\n// const CLIENT_ID = \"07f45b95ceac490ba0871336604107e0\"\n// const CLIENT_SECRET = \"2896dd203a234606ab0e2ba2a2aa5ad8\"\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst REFRESH_URL = \"http://localhost:8080/auth/refresh_token/\";\nfunction App() {\n  _s();\n  // get track information about the currently playing track\n  const getCurrentTrack = async () => {\n    if (window.localStorage.getItem(\"code\") === null) {\n      return;\n    }\n    try {\n      // send a request to the spotify api\n      const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n        headers: {\n          Authorization: `Bearer ${window.localStorage.getItem(\"access-token\")}`\n        }\n      });\n      if (response !== undefined) {\n        let trackName = response.data.item.name,\n          artistName = response.data.item.artists[0].name,\n          // TODO: could be more than one artists\n          trackID = response.data.item.id,\n          trackImg = response.data.item.album.images[0].url;\n        return {\n          trackName,\n          artistName,\n          trackID,\n          trackImg\n        };\n      } else {\n        return null;\n      }\n    } catch (error) {\n      console.log(error);\n      // if (error.response.status === 401) {\n      //   window.localStorage.removeItem(\"access-token\")\n      // }\n    }\n  };\n\n  // get the progress of the current track\n  const getProgress = async () => {\n    // don't send request if the user is not logged in\n    if (window.localStorage.getItem(\"code\") === null) {\n      return;\n    }\n    try {\n      // send request to the spotify api\n      const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n        headers: {\n          Authorization: `Bearer ${window.localStorage.getItem(\"access-token\")}`\n        }\n      });\n      if (response !== undefined) {\n        let startTime = response.data.progress_ms;\n        return startTime;\n      } else {\n        return null;\n      }\n    } catch (error) {\n      console.log(error);\n      if (error.response.status === 401) {\n        window.localStorage.removeItem(\"access-token\");\n      }\n    }\n  };\n\n  // triggered everytime a new track is played\n  const handleTrackChange = async () => {\n    setCurrentLineIndex(0); // lyrics line index reset\n    setCurrentTime(await getProgress()); // to align with lyrics timestamp\n    setTractStartTime(Date.now()); // use real time to keep track of the progress of the track\n    await getLyrics(); // fetch lyrics of the current track\n  };\n\n  // get lyrics of the current track\n  const getLyrics = async () => {\n    try {\n      // send request to the spotify api\n      const response = await axios.get(`https://spotify-lyric-api.herokuapp.com/?trackid=${track.trackID}`, {});\n      if (response !== undefined) {\n        // remove unnecessary information\n        var lines = response.data.lines.map(lineObj => {\n          delete lineObj.endTimeMs;\n          delete lineObj.syllables;\n          return lineObj;\n        });\n        setLyrics(lines); // update lyrics\n      } else {\n        // update lyrics to empty words if cannot find lyrics for the current track\n        setLyrics([{\n          startTimeMs: 0,\n          words: \" \"\n        }]);\n        console.log(\"lyrics not found\");\n        return null;\n      }\n    } catch (error) {\n      setLyrics([{\n        startTimeMs: 0,\n        words: \" \"\n      }]);\n      console.log(\"lyrics not found\");\n      return null;\n    }\n  };\n\n  // refresh token so that the user stays logged in\n  const refreshToken = async () => {\n    console.log(\"refreshing token\");\n    try {\n      // send request through express API\n      let response = await axios.get(REFRESH_URL, {\n        params: {\n          refresh_token: window.localStorage.getItem(\"refresh-token\")\n        }\n      });\n      // Update the access token in your app state or local storage\n      const newAccessToken = response.data.access_token;\n      window.localStorage.setItem(\"access-token\", newAccessToken);\n      console.log(\"successfully refreshed token\");\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  // initialize state variables\n  const [track, setTrack] = useState({});\n  const [lyrics, setLyrics] = useState([]);\n  const [currentLineIndex, setCurrentLineIndex] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [trackStartTime, setTractStartTime] = useState(0);\n\n  // triggered at every track change\n  useEffect(() => {\n    if (Object.keys(track).length !== 0) {\n      setCurrentLineIndex(0);\n      handleTrackChange();\n      refreshToken(); // refresh the access token after every song\n    }\n  }, [track]);\n\n  // general synchronization\n  useEffect(() => {\n    // asynchronze function to fetch a new track\n    const fetchNewTrack = async () => {\n      const newTrack = await getCurrentTrack();\n      if (newTrack && JSON.stringify(newTrack) !== JSON.stringify(track)) {\n        setTrack(newTrack);\n      }\n    };\n    const intervalId = setInterval(async () => {\n      // setCurrentTime(Date.now() - trackStartTime);\n      var progress = Date.now() - trackStartTime + currentTime;\n      if (track) {\n        const index = lyrics.findIndex(line => line.startTimeMs >= progress); // Find the index of the line with a start time greater than or equal to the current time\n        if (index !== -1 && index !== currentLineIndex) {\n          setCurrentLineIndex(index > 0 ? index - 1 : 0);\n        }\n      }\n\n      // check for new track only every two seconds\n      if (progress % 2500 < 100) {\n        fetchNewTrack();\n      }\n\n      // correct synchronization every five seconds\n      if (progress % 5000 < 100) {\n        console.log(\"correction...\");\n        setCurrentTime(await getProgress());\n        setTractStartTime(Date.now());\n      }\n    }, 100);\n    return () => clearInterval(intervalId);\n  }, [currentTime, lyrics]);\n\n  // render page elements\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: lyrics.length > 0 ? /*#__PURE__*/_jsxDEV(Lyrics, {\n      lines: lyrics,\n      currentLineIndex: currentLineIndex,\n      bg_img: track.trackImg\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 28\n    }, this) : /*#__PURE__*/_jsxDEV(Header, {\n      initToken: window.localStorage.getItem(\"token\")\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 115\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 176,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"V9rNfqwujw8lFck65OCxpOWN7HU=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["useEffect","useState","Header","Lyrics","axios","jsxDEV","_jsxDEV","REFRESH_URL","App","_s","getCurrentTrack","window","localStorage","getItem","response","get","headers","Authorization","undefined","trackName","data","item","name","artistName","artists","trackID","id","trackImg","album","images","url","error","console","log","getProgress","startTime","progress_ms","status","removeItem","handleTrackChange","setCurrentLineIndex","setCurrentTime","setTractStartTime","Date","now","getLyrics","track","lines","map","lineObj","endTimeMs","syllables","setLyrics","startTimeMs","words","refreshToken","params","refresh_token","newAccessToken","access_token","setItem","setTrack","lyrics","currentLineIndex","currentTime","trackStartTime","Object","keys","length","fetchNewTrack","newTrack","JSON","stringify","intervalId","setInterval","progress","index","findIndex","line","clearInterval","className","children","bg_img","fileName","_jsxFileName","lineNumber","columnNumber","initToken","_c","$RefreshReg$"],"sources":["C:/Study/VS Code/spotify-lyrics-sync/client/src/App.js"],"sourcesContent":["import {useEffect, useState} from 'react';\nimport Header from './components/Header';\nimport Lyrics from './components/Lyrics';\nimport axios from 'axios';\n\n// const CLIENT_ID = \"07f45b95ceac490ba0871336604107e0\"\n// const CLIENT_SECRET = \"2896dd203a234606ab0e2ba2a2aa5ad8\"\nconst REFRESH_URL = \"http://localhost:8080/auth/refresh_token/\"\n\nfunction App() {\n\n  // get track information about the currently playing track\n  const getCurrentTrack = async () => {\n    if (window.localStorage.getItem(\"code\") === null) {\n      return;\n    }\n    try {\n      // send a request to the spotify api\n      const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n        headers: {\n          Authorization: `Bearer ${window.localStorage.getItem(\"access-token\")}`\n        },\n      })\n      if (response !== undefined) {\n        let trackName = response.data.item.name,\n            artistName = response.data.item.artists[0].name,   // TODO: could be more than one artists\n            trackID = response.data.item.id,\n            trackImg = response.data.item.album.images[0].url\n        return { trackName, artistName, trackID, trackImg }\n      } else {\n        return null;\n      }\n    } catch (error) {\n      console.log(error);\n      // if (error.response.status === 401) {\n      //   window.localStorage.removeItem(\"access-token\")\n      // }\n    }\n    \n  }\n\n  // get the progress of the current track\n  const getProgress = async () => {\n    // don't send request if the user is not logged in\n    if (window.localStorage.getItem(\"code\") === null) {\n      return;\n    }\n    try {\n      // send request to the spotify api\n      const response = await axios.get(\"https://api.spotify.com/v1/me/player/currently-playing\", {\n        headers: {\n          Authorization: `Bearer ${window.localStorage.getItem(\"access-token\")}`\n        },\n      })\n      if (response !== undefined) {\n        let startTime = response.data.progress_ms\n        return startTime\n      } else {\n        return null;\n      }\n    } catch (error) {\n      console.log(error);\n      if (error.response.status === 401) {\n        window.localStorage.removeItem(\"access-token\")\n      }\n    }\n  }\n\n  // triggered everytime a new track is played\n  const handleTrackChange = async () => {\n    setCurrentLineIndex(0);     // lyrics line index reset\n    setCurrentTime(await getProgress());      // to align with lyrics timestamp\n    setTractStartTime(Date.now());      // use real time to keep track of the progress of the track\n    await getLyrics();    // fetch lyrics of the current track\n  };\n\n  // get lyrics of the current track\n  const getLyrics = async () => {\n    try {\n      // send request to the spotify api\n      const response = await axios.get(`https://spotify-lyric-api.herokuapp.com/?trackid=${track.trackID}`, {})\n      if (response !== undefined) {\n        // remove unnecessary information\n        var lines = response.data.lines.map(lineObj => {\n          delete lineObj.endTimeMs;\n          delete lineObj.syllables;\n          return lineObj;\n        })\n        setLyrics(lines);   // update lyrics\n      } else {\n        // update lyrics to empty words if cannot find lyrics for the current track\n        setLyrics([{startTimeMs: 0, words: \" \"}]);\n        console.log(\"lyrics not found\");\n        return null\n      }\n    } catch (error) {\n        setLyrics([{startTimeMs: 0, words: \" \"}]);\n        console.log(\"lyrics not found\");\n        return null\n    }\n    \n  }\n\n  // refresh token so that the user stays logged in\n  const refreshToken = async () => {\n    console.log(\"refreshing token\");\n    try {\n      // send request through express API\n      let response = await axios.get(REFRESH_URL, {\n        params: {\n          refresh_token: window.localStorage.getItem(\"refresh-token\")\n        }\n      })\n      // Update the access token in your app state or local storage\n      const newAccessToken = response.data.access_token;\n      window.localStorage.setItem(\"access-token\", newAccessToken)\n      console.log(\"successfully refreshed token\");\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  // initialize state variables\n  const [track, setTrack] = useState({});\n  const [lyrics, setLyrics] = useState([]);\n  const [currentLineIndex, setCurrentLineIndex] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [trackStartTime, setTractStartTime] = useState(0);\n\n  // triggered at every track change\n  useEffect(() => {\n    if (Object.keys(track).length !== 0) {\n      setCurrentLineIndex(0);\n      handleTrackChange();\n      refreshToken();   // refresh the access token after every song\n    }\n  }, [track]);\n\n  // general synchronization\n  useEffect(() => {\n    // asynchronze function to fetch a new track\n    const fetchNewTrack = async () => {\n      const newTrack = await getCurrentTrack();\n      if (newTrack && JSON.stringify(newTrack) !== JSON.stringify(track)) {\n        setTrack(newTrack);\n      }\n    };\n\n    const intervalId = setInterval(async () => {\n      // setCurrentTime(Date.now() - trackStartTime);\n      var progress = Date.now() - trackStartTime + currentTime;\n      if (track) {\n        const index = lyrics.findIndex((line) => line.startTimeMs >= progress); // Find the index of the line with a start time greater than or equal to the current time\n        if (index !== -1 && index !== currentLineIndex) {\n          setCurrentLineIndex(index > 0 ? index - 1 : 0);\n        }\n      }\n      \n      // check for new track only every two seconds\n      if (progress % 2500 < 100) {\n        fetchNewTrack();\n      }\n\n      // correct synchronization every five seconds\n      if (progress % 5000 < 100) {\n        console.log(\"correction...\");\n        setCurrentTime(await getProgress());\n        setTractStartTime(Date.now());\n      }\n    }, 100);\n    return () => clearInterval(intervalId);\n  }, [currentTime, lyrics]);\n\n  // render page elements\n  return (\n    <div className=\"container\">\n      {lyrics.length > 0 ? <Lyrics lines={lyrics} currentLineIndex={currentLineIndex} bg_img={track.trackImg}/> : <Header initToken={window.localStorage.getItem(\"token\")}/>}\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}